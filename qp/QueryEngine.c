/*****************************************************************************
* Model: query.qm
* File:  ./QueryEngine.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${QueryEng::.::QueryEngine.c} ............................................*/
#include "qp_port.h"
#include "QueryEngine.h"
#include <stdint.h>
#include "bsp.h"
#include "dbg_base.h"
#if 01
#include "dbg_trace.h"
#endif

static void HandleSysEvt(SystemEvent *evt);

static QueryEngine s_engine;
static QActive * s_pEngine = NULL;

QActive * AO_system(void) {
    if (!s_pEngine) {
        QueryEngine_ctor(&s_engine);
        s_pEngine = &s_engine;
    }
    return s_pEngine;
}

/*${QueryEng::QueryEngine} .................................................*/
/*${QueryEng::QueryEngine::ctor} ...........................................*/
void QueryEngine_ctor(QueryEngine * const me) {
    DBGMSG_M("Create");
    QActive_ctor(&me->super, Q_STATE_CAST(&QueryEngine_initial));
    QTimeEvt_ctorX(&me->timeEvt, &me->super, TIMEOUT_SIG, 0U);
}
/*${QueryEng::QueryEngine::SM} .............................................*/
QState QueryEngine_initial(QueryEngine * const me, QEvt const * const e) {
    /* ${QueryEng::QueryEngine::SM::initial} */
    (void)e;
    QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SECOND/2U, BSP_TICKS_PER_SECOND/2U);
    return Q_TRAN(&QueryEngine_Init);
}
/*${QueryEng::QueryEngine::SM::Working} ....................................*/
QState QueryEngine_Working(QueryEngine * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${QueryEng::QueryEngine::SM::Working} */
        case Q_ENTRY_SIG: {
            DBGMSG_M("Q_ENTRY");
            //QTimeEvt_armX(&me->timeEvt, BSP_TICKS_PER_SECOND/2U, BSP_TICKS_PER_SECOND/2U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${QueryEng::QueryEngine::SM::Working} */
        case Q_EXIT_SIG: {
            DBGMSG_M("Q_EXIT");
            status_ = Q_HANDLED();
            break;
        }
        /* ${QueryEng::QueryEngine::SM::Working::SYSTEM} */
        case SYSTEM_SIG: {
            DBGMSG_M("SYS");
            HandleSysEvt(e);
            status_ = Q_HANDLED();
            break;
        }
        /* ${QueryEng::QueryEngine::SM::Working::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&QueryEngine_Init);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${QueryEng::QueryEngine::SM::Working::Init} ..............................*/
QState QueryEngine_Init(QueryEngine * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${QueryEng::QueryEngine::SM::Working::Init::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&QueryEngine_Processing);
            break;
        }
        default: {
            status_ = Q_SUPER(&QueryEngine_Working);
            break;
        }
    }
    return status_;
}
/*${QueryEng::QueryEngine::SM::Working::Processing} ........................*/
QState QueryEngine_Processing(QueryEngine * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${QueryEng::QueryEngine::SM::Working::Processing::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&QueryEngine_Waiting);
            break;
        }
        default: {
            status_ = Q_SUPER(&QueryEngine_Working);
            break;
        }
    }
    return status_;
}
/*${QueryEng::QueryEngine::SM::Working::Waiting} ...........................*/
QState QueryEngine_Waiting(QueryEngine * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${QueryEng::QueryEngine::SM::Working::Waiting::TIMEOUT} */
        case TIMEOUT_SIG: {
            status_ = Q_TRAN(&QueryEngine_Done);
            break;
        }
        default: {
            status_ = Q_SUPER(&QueryEngine_Working);
            break;
        }
    }
    return status_;
}
/*${QueryEng::QueryEngine::SM::Working::Done} ..............................*/
QState QueryEngine_Done(QueryEngine * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&QueryEngine_Working);
            break;
        }
    }
    return status_;
}


static void HandleSysEvt(SystemEvent *evt) {

    extern void QueryTest(uint8_t *buff, size_t size);
    QueryTest(NULL, 0);

    Event_p event = &evt->event;
    switch (event->type) {
        case EVENT_EXTI: {
            DBGMSG_L("[Exti] pin %d act %d", event->data, event->subType.exti);
            char *text = "hello !";
            CanTxMsgTypeDef txMsg = {
                    0x22, 0,
                    CAN_ID_STD,
                    CAN_RTR_DATA,
                    8,
                    { text[0], text[1], text[2], text[3], text[4], text[5], text[6], text[7] }
            };
            USB_ACM_write((uint8_t*)text, strlen(text));
            CAN_write(&txMsg);
            } break;
        case EVENT_UART:
            UART_handleEvent(event);
            break;
        case EVENT_UxART_Buffer: {
            uint8_t *buff = (uint8_t *)event->data.uxart.buffer;
            size_t size = event->data.uxart.size;
            switch (event->subType.uxart) {
                case ES_UxART_RX:
                    DBGMSG_H("[RX] [%s]", buff);
                    QueryTest(buff, size);
                    MEMMAN_free(buff);
                    break;
                default:
                    break;
            }
        } break;
        case EVENT_CAN:
            CAN_handleEvent(event);
            break;
        case EVENT_SYSTICK:
            if (event->subType.systick == ES_SYSTICK_SECOND_ELAPSED) {
                Timer_makeTick();
            }
        case EVENT_USART:
            USART_handleEvent(event);
            break;
        case EVENT_DUMMY:
            break;
        default:
            DBGMSG_WARN("Unhandled Event type %p data %p!", event->type, event->data);
            break;
    }
}
