<?xml version="1.0" encoding="UTF-8"?>
<model version="3.3.0">
 <framework name="qpc"/>
 <package name="System" stereotype="0x04">
  <class name="Engine" superclass="qpc::QActive">
   <attribute name="timeEvt" type="QTimeEvt" visibility="0x00" properties="0x00"/>
   <attribute name="evtStorage[128]" type="QEvt const *" visibility="0x02" properties="0x00"/>
   <operation name="ctor" type="void" visibility="0x00" properties="0x00">
    <code>DBGMSG_M(&quot;Create&quot;);
QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;Engine_initial));
QTimeEvt_ctorX(&amp;me-&gt;timeEvt, &amp;me-&gt;super, TIMEOUT_SIG, 0U);</code>
   </operation>
   <statechart>
    <initial target="../1/2">
     <action>(void)e;
//QTimeEvt_armX(&amp;me-&gt;timeEvt, BSP_TICKS_PER_SECOND/2U, BSP_TICKS_PER_SECOND/2U);</action>
     <initial_glyph conn="4,2,5,0,14,7">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Working">
     <entry>DBGMSG_M(&quot;Q_ENTRY&quot;);</entry>
     <exit>DBGMSG_M(&quot;Q_EXIT&quot;);</exit>
     <tran trig="SYSTEM">
      <action>HandleSysEvt(e);</action>
      <tran_glyph conn="4,38,3,-1,11">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TIMEOUT" target="../2">
      <tran_glyph conn="4,19,3,3,6">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="Init">
      <entry>DBGMSG_M(&quot;Entry&quot;);
RequestEvent *evt = Q_NEW(RequestEvent, NEW_REQUEST_SIG);
evt-&gt;request = Request_GetInitial();
QACTIVE_POST(AO_QueryEngine(), evt, NULL);</entry>
      <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
      <tran trig="QUERY_DONE" target="../../3">
       <tran_glyph conn="31,16,1,3,6">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="10,9,21,19">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="Connect">
      <entry>DBGMSG_M(&quot;Entry&quot;);
systemConfig_p config = SystemConfig_get();
if (config-&gt;discoveredApnsSize &amp;&amp; config-&gt;knownApnsCount) {
    size_t i, j;
    size_t matchCount = 0;
    size_t matchIdx = -1;
    DBGMSG_M(&quot;Credentials/Found %d/%d&quot;, config-&gt;knownApnsCount, config-&gt;discoveredApnsSize);
    for (i = 0; i &lt; config-&gt;knownApnsCount; i++) {
        for (j = 0; j &lt; config-&gt;discoveredApnsSize; j++) {
            DBGMSG_H(&quot;[%s] == [%s]&quot;, config-&gt;knownApns[i].ssid, config-&gt;discoveredApns[j].ssid);
            if (!strcmp(config-&gt;knownApns[i].ssid, config-&gt;discoveredApns[j].ssid)) {
                DBGMSG_H(&quot; Match %d [%s]&quot;, i, config-&gt;knownApns[i].ssid);
                matchIdx = i;
                matchCount++;
            }
        }
    }
    if (matchCount) {
        if (matchCount == 1) {
           RequestEvent *evt = Q_NEW(RequestEvent, NEW_REQUEST_SIG);
           evt-&gt;request = Request_GetConnect(config-&gt;knownApns[matchIdx].ssid, config-&gt;knownApns[matchIdx].passwd);
           DBGMSG_H(&quot;Connect To &lt;%s&gt;:&lt;%s&gt;&quot;, config-&gt;knownApns[matchIdx].ssid, config-&gt;knownApns[matchIdx].passwd);
           QACTIVE_POST(AO_QueryEngine(), evt, NULL);
        } else {
            DBGMSG_ERR(&quot;TODO: implement multiple credentials&quot;);
        }
    }
}</entry>
      <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
      <tran trig="QUERY_DONE" target="../../4">
       <tran_glyph conn="58,16,1,3,6">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="37,9,21,19">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="UPnPDiscoverer">
      <entry>DBGMSG_M(&quot;Entry&quot;);
RequestEvent *evt = Q_NEW(RequestEvent, NEW_REQUEST_SIG);
evt-&gt;request = Request_GetUPnPDiscoverer();
QACTIVE_POST(AO_QueryEngine(), evt, NULL);</entry>
      <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
      <tran trig="QUERY_DONE" target="../../5">
       <tran_glyph conn="75,28,2,0,5">
        <action box="-6,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="64,9,21,19">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="GetRootXml">
      <entry>DBGMSG_M(&quot;Entry&quot;);
RequestEvent *evt = Q_NEW(RequestEvent, NEW_REQUEST_SIG);
evt-&gt;request = Request_GetRootXml();
QACTIVE_POST(AO_QueryEngine(), evt, NULL);</entry>
      <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
      <state_glyph node="64,33,21,19">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="4,5,84,55">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="130,61"/>
   </statechart>
  </class>
  <class name="SystemEvent" superclass="qpc::QEvt">
   <attribute name="event" type="Event_t" visibility="0x00" properties="0x00"/>
  </class>
  <class name="QueryEngine" superclass="qpc::QActive">
   <attribute name="evtStorage[128]" type="QEvt const *" visibility="0x02" properties="0x00"/>
   <attribute name="stepTout" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="queryTout" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="request" type="Request_p" visibility="0x02" properties="0x00"/>
   <operation name="ctor" type="void" visibility="0x00" properties="0x00">
    <code>DBGMSG_M(&quot;Create&quot;);
QActive_ctor(&amp;me-&gt;super, Q_STATE_CAST(&amp;QueryEngine_initial));
QTimeEvt_ctorX(&amp;me-&gt;stepTout, &amp;me-&gt;super, STEP_TIMEOUT_SIG, 0U);
QTimeEvt_ctorX(&amp;me-&gt;queryTout, &amp;me-&gt;super, QUERY_TIMEOUT_SIG, 0U);
me-&gt;request = NULL;</code>
   </operation>
   <statechart>
    <initial target="../1">
     <action>(void)e;</action>
     <initial_glyph conn="2,2,5,0,11,2">
      <action box="0,-2,10,2"/>
     </initial_glyph>
    </initial>
    <state name="Idle">
     <entry>DBGMSG_M(&quot;Entry&quot;);</entry>
     <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
     <tran trig="NEW_REQUEST" target="../../2/2">
      <action>RequestEvent *evt = (RequestEvent*)e;
me-&gt;request = evt-&gt;request;</action>
      <tran_glyph conn="20,10,1,3,14">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="QUERY_TIMEOUT">
      <tran_glyph conn="4,19,3,-1,7">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="STEP_TIMEOUT">
      <tran_glyph conn="4,15,3,-1,7">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="4,4,16,20">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state name="Working">
     <entry>DBGMSG_M(&quot;Entry&quot;);</entry>
     <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
     <tran trig="STEP_FAILED" target="../4">
      <action>DBGMSG_M(&quot;STEP_FAILED&quot;);</action>
      <tran_glyph conn="78,33,1,2,-6,-3">
       <action box="-5,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="QUERY_DONE" target="../../1">
      <action>DBGMSG_M(&quot;QUERY_DONE_SIG&quot;);
me-&gt;request-&gt;state = QUERY_DONE;
QACTIVE_POST(AO_system(), Q_NEW(QEvt, QUERY_DONE_SIG), NULL);
</action>
      <tran_glyph conn="30,17,3,1,-10">
       <action box="-8,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="StepInit">
      <entry>DBGMSG_M(&quot;Entry&quot;);
if (me-&gt;request-&gt;stepCurrent &lt; me-&gt;request-&gt;stepsCount) {
    _Bool continueStepping = true;
    Step_p step = step = &amp;(me-&gt;request-&gt;steps[me-&gt;request-&gt;stepCurrent]);
    me-&gt;request-&gt;state = QUERY_PROCESSING;
    if (step-&gt;start) {
        continueStepping = step-&gt;start(me-&gt;request);
        me-&gt;request-&gt;state = QUERY_WAITING;
        DBGMSG_M(&quot;Starting: %u\n\r%s&quot;, me-&gt;request-&gt;stepCurrent, me-&gt;request-&gt;tx.buff);
    }
    QACTIVE_POST(AO_QueryEngine(), Q_NEW(QEvt, continueStepping ? STEP_NEXT_SIG : STEP_FAILED_SIG), NULL);
} else {
    QACTIVE_POST(AO_QueryEngine(), Q_NEW(QEvt, QUERY_DONE_SIG), NULL);
}</entry>
      <exit>DBGMSG_M(&quot;Exit&quot;);</exit>
      <tran trig="STEP_NEXT" target="../../3">
       <action>DBGMSG_M(&quot;STEP_NEXT&quot;);</action>
       <tran_glyph conn="50,22,1,1,2,8,-2">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="34,8,16,16">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="StepWaiting">
      <entry>DBGMSG_M(&quot;Entry&quot;);
BSP_espSend(me-&gt;request-&gt;tx.buff, me-&gt;request-&gt;tx.occupied);</entry>
      <tran trig="NEW_DATA, STEP_TIMEOUT">
       <action>DBGMSG_H(&quot;%s&quot;, e-&gt;sig == NEW_DATA_SIG ? &quot;NEW_DATA_SIG&quot; : &quot;STEP_TIMEOUT_SIG&quot; );
Step_p step = &amp;(me-&gt;request-&gt;steps[me-&gt;request-&gt;stepCurrent]);
_Bool ackOk = false;
if (e-&gt;sig == NEW_DATA_SIG) {
    handleNewBuffer(me-&gt;request, (SystemEvent*)e);
}</action>
       <choice>
        <guard brief="ack?">isStepAck(me-&gt;request, &amp;ackOk)</guard>
        <action>DBGMSG_M(&quot;Got Ack&quot;);</action>
        <choice>
         <guard brief="OK">ackOk</guard>
         <choice target="../../../../../2">
          <guard>else</guard>
          <action>DBGMSG_H(&quot;Successed: %u&quot;, me-&gt;request-&gt;stepCurrent);
if (step-&gt;success) {
    step-&gt;success(me-&gt;request);
}
MEMMAN_free(me-&gt;request-&gt;rx.buff);
me-&gt;request-&gt;rx.occupied = 0;
me-&gt;request-&gt;tx.occupied = 0;
me-&gt;request-&gt;stepCurrent++;</action>
          <choice_glyph conn="32,44,4,3,-24,2">
           <action box="-4,-4,10,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="Wait">(e-&gt;sig == NEW_DATA_SIG) &amp;&amp; (step-&gt;falgs &amp; STEP_FLAG_WAIT_TOUT)</guard>
          <action>if (!me-&gt;stepTout.ctr) {
    DBGMSG_H(&quot;Waiting for %u ticks&quot;, step-&gt;timeout);
    QTimeEvt_armX(&amp;me-&gt;stepTout, step-&gt;timeout, 0U);
}</action>
          <choice_glyph conn="32,44,5,-1,-7">
           <action box="-5,0,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="41,44,5,-1,-9">
          <action box="-7,-2,4,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../4">
         <guard brief="err">else</guard>
         <action>DBGMSG_H(&quot;Fail: %u\n\r%s&quot;, me-&gt;request-&gt;stepCurrent, me-&gt;request-&gt;tx.buff);
</action>
         <choice_glyph conn="41,44,5,2,26,-14">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <choice_glyph conn="41,34,4,-1,10">
         <action box="-5,1,5,2"/>
        </choice_glyph>
       </choice>
       <tran_glyph conn="41,26,0,-1,8">
        <action box="-4,2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="34,26,16,11">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="StepFailed">
      <entry>Step_p step = step = &amp;(me-&gt;request-&gt;steps[me-&gt;request-&gt;stepCurrent]);
DBGMSG_H(&quot;Failed step %d&quot;, me-&gt;request-&gt;stepCurrent);
me-&gt;request-&gt;state = QUERY_FAILED;
if (step-&gt;fail) {
    step-&gt;fail(me-&gt;request);
}
QACTIVE_POST(AO_QueryEngine(), Q_NEW(QEvt, STEP_FAILED_SIG), NULL);</entry>
      <tran trig="STEP_FAILED" target="../../../1">
       <action>DBGMSG_M(&quot;STEP_FAILED&quot;);</action>
       <tran_glyph conn="70,10,0,0,-8,-53,2">
        <action box="-10,-8,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="65,10,11,20">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="30,4,48,44">
      <entry box="1,2,6,2"/>
      <exit box="1,4,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="80,50"/>
   </statechart>
  </class>
  <class name="RequestEvent" superclass="qpc::QEvt">
   <attribute name="request" type="Request_p" visibility="0x02" properties="0x00"/>
  </class>
  <directory name=".">
   <file name="Engine.h">
    <text>#pragma once

#include &quot;qp_port.h&quot;
#include &quot;Events.h&quot;
#include &quot;Query.h&quot;

enum BlinkySignals {
    DUMMY_SIG = Q_USER_SIG,
    SYSTEM_SIG,
    TIMEOUT_SIG,
    NEW_REQUEST_SIG,
    NEW_DATA_SIG,
    STEP_NEXT_SIG,
    STEP_FAILED_SIG,
    STEP_TIMEOUT_SIG,
    QUERY_TIMEOUT_SIG,
    QUERY_DONE_SIG,
    QUERY_FAILED_SIG,
    MAX_SIG               /* the last signal */
};

QActive *AO_system(void);

$declare(System::SystemEvent)
$declare(System::RequestEvent)

$declare(System::Engine)</text>
   </file>
   <file name="Engine.c">
    <text>#include &quot;qp_port.h&quot;
#include &quot;Engine.h&quot;
#include &quot;QueryEngine.h&quot;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &quot;requests.h&quot;
#include &quot;bsp.h&quot;
#include &quot;dbg_base.h&quot;
#if 01
#include &quot;dbg_trace.h&quot;
#endif

static void HandleSysEvt(SystemEvent *evt);

static Engine s_engine;
static QActive * s_pEngine = NULL;

QActive * AO_system(void) {
    if (!s_pEngine) {
        Engine_ctor(&amp;s_engine);
        s_pEngine = (QActive*)&amp;s_engine;
    }
    return s_pEngine;
}

$define(System::Engine)

static void HandleSysEvt(SystemEvent *evt) {

    Event_p event = &amp;evt-&gt;event;
    switch (event-&gt;type) {
        case EVENT_EXTI: {
            DBGMSG_L(&quot;[Exti] pin %d act %d&quot;, event-&gt;data, event-&gt;subType.exti);
            char *text = &quot;hello !&quot;;
            CanTxMsgTypeDef txMsg = {
                    0x22, 0,
                    CAN_ID_STD,
                    CAN_RTR_DATA,
                    8,
                    { text[0], text[1], text[2], text[3], text[4], text[5], text[6], text[7] }
            };
            USB_ACM_write((uint8_t*)text, strlen(text));
            CAN_write(&amp;txMsg);
            } break;
        case EVENT_UART:
            UART_handleEvent(event);
            break;
        case EVENT_UxART_Buffer: {
            switch (event-&gt;subType.uxart) {
                case ES_UxART_RX: {
                    SystemEvent *evt = Q_NEW(SystemEvent, NEW_DATA_SIG);
                    evt-&gt;event = *event;
                    QACTIVE_POST(AO_QueryEngine(), evt, NULL);
                    } break;
                default:
                    break;
            }
        } break;
        case EVENT_CAN:
            CAN_handleEvent(event);
            break;
        case EVENT_SYSTICK:
            if (event-&gt;subType.systick == ES_SYSTICK_SECOND_ELAPSED) {
                Timer_makeTick();
            }
        case EVENT_USART:
            USART_handleEvent(event);
            break;
        case EVENT_DUMMY:
            break;
        default:
            DBGMSG_WARN(&quot;Unhandled Event type %p data %p!&quot;, event-&gt;type, event-&gt;data);
            break;
    }
}</text>
   </file>
   <file name="QueryEngine.h">
    <text>#pragma once

#include &quot;Engine.h&quot;
#include &quot;Query.h&quot;

QActive *AO_QueryEngine(void);

$declare(System::QueryEngine)</text>
   </file>
   <file name="QueryEngine.c">
    <text>
#include &quot;QueryEngine.h&quot;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &quot;memman.h&quot;
#include &quot;bsp.h&quot;
#include &quot;dbg_base.h&quot;
#if 01
#include &quot;dbg_trace.h&quot;
#endif

static QueryEngine s_queryEng;
static QActive * s_pQueryEng = NULL;

static void handleNewBuffer(Request_p req, SystemEvent *evt);
static _Bool isStepAck(Request_p req, _Bool *isOk);

QActive * AO_QueryEngine(void) {
    if (!s_pQueryEng) {
        QueryEngine_ctor(&amp;s_queryEng);
        s_pQueryEng = (QActive*)&amp;s_queryEng;
    }
    return s_pQueryEng;
}

$define(System::QueryEngine)

static void handleNewBuffer(Request_p req, SystemEvent *evt) {
    char *buff = (char*)evt-&gt;event.data.uxart.buffer;
    size_t size = evt-&gt;event.data.uxart.size;
    if (buff &amp;&amp; size) {
        char *start = MEMMAN_malloc(req-&gt;rx.occupied + size + 3);
        memset((void*)start, 0, req-&gt;rx.occupied + size + 3);
        char *ptr = start;
        if (req-&gt;rx.occupied) {
            memcpy((void*)start, (void*)req-&gt;rx.buff, req-&gt;rx.occupied);
            MEMMAN_free((void*)req-&gt;rx.buff);
            start[req-&gt;rx.occupied++] = '\n';
            start[req-&gt;rx.occupied++] = '\r';
            ptr = &amp;start[req-&gt;rx.occupied];
        }
        memcpy((void*)ptr, (void*)buff, size);
        req-&gt;rx.buff = start;
        req-&gt;rx.occupied += size;
        start[req-&gt;rx.occupied] = '\0';
    }
}

static _Bool isStepAck(Request_p req, _Bool *isOk) {
    _Bool result = false;
    static const char *const ackError = &quot;ERROR&quot;;
    const size_t ackErrorSize = strlen(ackError);
    do {
        if (!req || !isOk || !req-&gt;rx.occupied)
            break;
        const char *const ackOk = req-&gt;steps[req-&gt;stepCurrent].acknowledge ? req-&gt;steps[req-&gt;stepCurrent].acknowledge : &quot;OK&quot;;
        const size_t ackOkSize = strlen(ackOk);
        *isOk = false;
        if (req-&gt;rx.occupied &gt;= ackErrorSize) {
            char *ptr = (char*)&amp;req-&gt;rx.buff[req-&gt;rx.occupied - ackErrorSize];
            if (!strcmp(ptr, ackError)) {
                result = true;
                break;
            }
        }
        if (req-&gt;rx.occupied &gt;= ackOkSize) {
            char *ptr = (char*)&amp;req-&gt;rx.buff[req-&gt;rx.occupied - ackOkSize];
            if (!strcmp(ptr, ackOk)) {
                if ((req-&gt;rx.occupied &lt;= ackOkSize) || (*(ptr - 1) == '\r')) {
                    *isOk = true;
                    result = true;
                    break;
                }
            }
        }

    } while (0);
    return result;
}</text>
   </file>
  </directory>
 </package>
</model>
